{% extends "layout.html" %}
{% block content %}
<article class="media content-section">
    <div class="media-body">
        <div class="article-metadata">
            <h2>{{ post.author.username }}</h2>
            <small class="text-muted">{{ post.date_posted.strftime('%Y-%m-%d %H:%M') }}</small>
        </div>
        <p class="article-content">{{ post.content }}</p>
    </div>
</article>

{% for comment in comments %}
<article class="media content-section">
    <div class="media-body">
        <p class="article-content">{{ comment.content }}</p>
        <small class="text-muted">{{ comment.date_posted.strftime('%Y-%m-%d %H:%M') }}</small>
    </div>
</article>
{% endfor %}

{% if current_user.is_authenticated and (current_user.id == post.user_id or current_user.is_mechanic()) %}
<div class="content-section">
    <form method="POST" action="">
        {{ form.hidden_tag() }}
        <fieldset class="form-group">
            <div class="form-group">
                {{ form.content.label(class="form-control-label") }}
                {{ form.content(class="form-control form-control-lg", id="comment-content") }}
            </div>
            <div class="input-group mt-2">
                <div class="input-group-append">
                    <button type="button" class="btn btn-outline-secondary" id="comment-record-button">üé§ Start Recording</button>
                </div>
            </div>
        </fieldset>
        <div class="form-group">
            {{ form.submit(class="btn btn-primary btn-lg") }}
        </div>
    </form>
</div>

<script>
    let isRecording = false;
    let mediaRecorder;
    let audioChunks = [];

    document.addEventListener('DOMContentLoaded', (event) => {
        const recordButton = document.getElementById('comment-record-button');
        if (recordButton) {
            recordButton.addEventListener('click', () => {
                if (isRecording) {
                    mediaRecorder.stop();
                    isRecording = false;
                    recordButton.innerText = "üé§ Start Recording";
                } else {
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                            mediaRecorder.start();
                            isRecording = true;
                            audioChunks = [];
                            recordButton.innerText = "‚èπÔ∏è Stop Recording";

                            mediaRecorder.ondataavailable = event => {
                                audioChunks.push(event.data);
                            };

                            mediaRecorder.onstop = () => {
                                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

                                const audioContext = new AudioContext();
                                const fileReader = new FileReader();
                                fileReader.onload = function() {
                                    audioContext.decodeAudioData(fileReader.result, function(buffer) {
                                        const offlineContext = new OfflineAudioContext(buffer.numberOfChannels, buffer.duration * 48000, 48000);
                                        const source = offlineContext.createBufferSource();
                                        source.buffer = buffer;
                                        source.connect(offlineContext.destination);
                                        source.start(0);
                                        offlineContext.startRendering().then(renderedBuffer => {
                                            const downsampledAudioBlob = bufferToWave(renderedBuffer);
                                            const formData = new FormData();
                                            formData.append('audio', downsampledAudioBlob, 'audio.wav');
                                            formData.append('channels', renderedBuffer.numberOfChannels);

                                            fetch('{{ url_for("speech_to_text") }}', {
                                                method: 'POST',
                                                body: formData
                                            })
                                            .then(response => response.json())
                                            .then(data => {
                                                console.log('Server response:', data); // Log the server response for debugging
                                                if (data.transcript) {
                                                    document.getElementById('comment-content').value = data.transcript;
                                                } else {
                                                    alert('Error in transcription: ' + data.error);
                                                }
                                            })
                                            .catch(error => console.error('Error:', error));
                                        });
                                    });
                                };
                                fileReader.readAsArrayBuffer(audioBlob);
                            };
                        })
                        .catch(error => {
                            console.error('Error accessing audio stream:', error);
                            alert('Error accessing audio stream. Please check your microphone permissions.');
                        });
                }
            });
        }
    });

    function bufferToWave(buffer) {
        let numOfChan = buffer.numberOfChannels,
            length = buffer.length * numOfChan * 2 + 44,
            bufferArray = new ArrayBuffer(length),
            view = new DataView(bufferArray),
            channels = [], i, sample,
            offset = 0, pos = 0;

        setUint16(0x46464952);
        setUint32(length - 8);
        setUint32(0x45564157);

        setUint32(0x20746D66);
        setUint32(16);
        setUint16(1);
        setUint16(numOfChan);
        setUint32(48000);
        setUint32(48000 * 2 * numOfChan);
        setUint16(numOfChan * 2);
        setUint16(16);

        setUint32(0x61746164);
        setUint32(length - pos - 4);

        for(i = 0; i < buffer.length; i++) {
            for (let channel = 0; channel < numOfChan; channel++) {
                sample = buffer.getChannelData(channel)[i] * 0x7FFF;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
        }

        return new Blob([bufferArray], { type: "audio/wav" });

        function setUint16(data) {
            view.setUint16(pos, data, true);
            pos += 2;
        }

        function setUint32(data) {
            view.setUint32(pos, data, true);
            pos += 4;
        }
    }
</script>
{% else %}
<p class="text-muted">–°–∞–º–æ –º–µ—Ö–∞–Ω–∏—Ü–∏ –º–æ–≥–∞—Ç –¥–∞ –æ—Ç–≥–æ–≤–∞—Ä—è—Ç –Ω–∞ –∑–∞–ø–∏—Ç–≤–∞–Ω–∏—è.</p>
{% endif %}
{% endblock %}
