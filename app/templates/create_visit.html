{% extends "layout.html" %}

{% block content %}
<div class="container mt-4">
    <div class="content-section">
        <h2>–†–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞–π –ø–æ—Å–µ—â–µ–Ω–∏–µ –Ω–∞ –∞–≤—Ç–æ–º–æ–±–∏–ª–∞: {{ car.registration_number }}</h2>
        <form id="visit-form" method="POST" action="{{ url_for('create_visit', car_id=car.id) }}" enctype="multipart/form-data">
            {{ form.hidden_tag() }}
            <div class="form-group">
                <label for="description">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ —Ä–µ–º–æ–Ω—Ç–∞</label>
                {{ form.description(class="form-control") }}
                <div class="input-group mt-2">
                    <div class="input-group-append">
                        <button type="button" class="btn btn-outline-secondary" id="record-button">üé§ –ó–∞–ø–æ—á–Ω–∏ –∑–∞–ø–∏—Å</button>
                    </div>
                </div>
            </div>
            <button type="submit" class="btn btn btn-primary">–ó–∞–ø–∞–∑–∏</button>
        </form>
    </div>
</div>

<script>
  let isRecording = false;
  let mediaRecorder;
  let audioChunks = [];

  document.addEventListener('DOMContentLoaded', (event) => {
    const recordButton = document.getElementById('record-button');
    if (recordButton) {
      recordButton.addEventListener('click', () => {
        if (isRecording) {
          mediaRecorder.stop();
          isRecording = false;
          recordButton.innerText = "üé§ –ó–∞–ø–æ—á–Ω–∏ –∑–∞–ø–∏—Å";
        } else {
          navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
              mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
              mediaRecorder.start();
              isRecording = true;
              audioChunks = [];
              recordButton.innerText = "‚èπÔ∏è –°–ø—Ä–∏ –∑–∞–ø–∏—Å";

              mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
              };

              mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

                const audioContext = new AudioContext();
                const fileReader = new FileReader();
                fileReader.onload = function() {
                  audioContext.decodeAudioData(fileReader.result, function(buffer) {
                    const offlineContext = new OfflineAudioContext(buffer.numberOfChannels, buffer.duration * 48000, 48000);
                    const source = offlineContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(offlineContext.destination);
                    source.start(0);
                    offlineContext.startRendering().then(renderedBuffer => {
                      const downsampledAudioBlob = bufferToWave(renderedBuffer);
                      const formData = new FormData();
                      formData.append('audio', downsampledAudioBlob, 'audio.wav');
                      formData.append('channels', renderedBuffer.numberOfChannels);

                      fetch('{{ url_for("speech_to_text") }}', {
                        method: 'POST',
                        body: formData
                      })
                      .then(response => response.json())
                      .then(data => {
                        if (data.transcript) {
                          document.getElementById('description').value = data.transcript;
                        } else {
                          alert('–ì—Ä–µ—à–∫–∞ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è—Ç–∞: ' + data.error);
                        }
                      })
                      .catch(error => console.error('Error:', error));
                    });
                  });
                };
                fileReader.readAsArrayBuffer(audioBlob);
              };
            })
            .catch(error => {
              console.error('Error accessing audio stream:', error);
              alert('Error accessing audio stream. Please check your microphone permissions.');
            });
        }
      });
    }
  });

  function bufferToWave(buffer) {
    let numOfChan = buffer.numberOfChannels,
        length = buffer.length * numOfChan * 2 + 44,
        bufferArray = new ArrayBuffer(length),
        view = new DataView(bufferArray),
        channels = [], i, sample,
        offset = 0, pos = 0;

    setUint32(0x46464952);
    setUint32(length - 8);
    setUint32(0x45564157);

    setUint32(0x20746D66);
    setUint32(16);
    setUint16(1);
    setUint16(numOfChan);
    setUint32(48000);
    setUint32(48000 * 2 * numOfChan);
    setUint16(numOfChan * 2);
    setUint16(16);

    setUint32(0x61746164);
    setUint32(length - pos - 4);

    for(i = 0; i < buffer.length; i++) {
      for (let channel = 0; channel < numOfChan; channel++) {
        sample = buffer.getChannelData(channel)[i] * 0x7FFF;
        view.setInt16(pos, sample, true);
        pos += 2;
      }
    }

    return new Blob([bufferArray], { type: "audio/wav" });

    function setUint16(data) {
      view.setUint16(pos, data, true);
      pos += 2;
    }

    function setUint32(data) {
      view.setUint32(pos, data, true);
      pos += 4;
    }
  }
</script>
{% endblock %}
